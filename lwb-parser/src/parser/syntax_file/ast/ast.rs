#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
use super::prelude::*;
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct Program<M>(pub M, pub Vec<SortOrMeta<M>>);
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum SortOrMeta<M> {
    Meta(M, Meta<M>),
    Sort(M, Sort<M>),
}
///Other top-level constructs that are not sorts
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct Meta<M>(pub M, pub Identifier<M>);
///A sort is a group of constructors. See [`constructor`] for more details.
///
///There is one special sort, called `layout`. It can be used to denote
///that a grammar should for example ignore certain whitespace or comments.
///Between every part of an expression, the parser will attempt to parse the
///layout sort 0 or more times, and throw away whatever it parses.
///
///Sorts can have doc-comments using triple slashes.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum Sort<M> {
    SortDocumented(M, Vec<DocComment<M>>, Box<Sort<M>>),
    Sort(
        M,
        Identifier<M>,
        Option<AnnotationList<M>>,
        Vec<Constructor<M>>,
    ),
    ///When a sort has only one constructor, it has simpler syntax.
    SortSingle(
        M,
        Identifier<M>,
        Vec<Expression<M>>,
        Option<AnnotationList<M>>,
    ),
}
///An identifier is any name of a constructor or sort, and is used in various places.
///Identifiers always start with a letter (capital or not) or an underscore, and can be
///followed by letters or numbers. This is very similar to how variables in most major
///programming languages work.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct Identifier<M>(pub M, pub std::string::String);
///A documentation comment (doc comment) is always associated with a sort
///or constructor. It documents what it does. Doc comments will be interpreted
///and will be put on the generated types during codegen.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct DocComment<M>(pub M, pub std::string::String);
///Annotations are tags that modify a specific sort or more often constructor.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct AnnotationList<M>(pub M, pub Vec<Annotation<M>>);
///A [`sort`] consists of constructors. A sort will try each of the constructors
///from top to bottom, and use the first one that successfully parses the input string.
///
///A constructor consists of a name, followed by an [`expression`]
///
///Constructors can have doc-comments using triple slashes.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum Constructor<M> {
    ConstructorDocumented(M, Vec<DocComment<M>>, Box<Constructor<M>>),
    Constructor(
        M,
        Identifier<M>,
        Vec<Expression<M>>,
        Option<AnnotationList<M>>,
    ),
    ///using `test;` as a constructor desugars to `test = test;`
    ConstructorBare(M, Identifier<M>, Option<AnnotationList<M>>),
}
///With expressions, you can give the syntax rules of a single constructor.
///Expressions can be nested and combined.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum Expression<M> {
    ///Repeat some expression zero or more times
    ///Equivalent to `<expression> {0,}`
    Star(M, Atom<M>),
    ///Repeat some expression one or more times
    ///Equivalent to `<expression> {1,}`
    Plus(M, Atom<M>),
    ///Optionally have some expression.
    ///Equivalent to `<expression> {0,1}`
    Maybe(M, Atom<M>),
    ///Exact repetition. The expression is repeated an exact number of times. Equivalent
    ///to ranged repetition with an equal lower and upper bound.
    RepeatExact(M, Atom<M>, Number<M>),
    ///Ranged repetition. The expression may be repeated any number of times, within the range.
    ///Both bounds are inclusive.
    RepeatRange(M, Atom<M>, Number<M>, Number<M>),
    ///Ranged repetition, without upper bound (or an infinite maximum)
    RepeatLower(M, Atom<M>, Number<M>),
    ///Delimited expressions. Says that some expression should be repeatedly parsed,
    ///but between two parses, a delimiter should be parsed too. For example, comma seperated expressions.
    ///The final trailing keyword enables a trailing separator after the sequence. If not present, no trailing
    ///separator is allowed.
    Delimited(
        M,
        Box<Expression<M>>,
        Box<Expression<M>>,
        DelimitedBound<M>,
        bool,
    ),
    Atom(M, Atom<M>),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum Annotation<M> {
    ///Mark a constructor as being a mapping from sort x to sort x.
    ///An example is a parenthesis rule:
    ///```lwb,no_run
    ///expr:
    ///paren = "(" expr ")"
    ///```
    ///
    ///In that case you don't want a variant in the expr rule that's called "paren".
    ///Instead, by adding the `injection` annotation you tell the parser that this rule is purely to create a new priority level,
    ///but to use the inner expr as the result of the parse. Thus there will be no rule called "paren".
    Injection(M),
    ///disable pretty printing. Doesn't work well anyway so don't bother with this annotation
    NoPrettyPrint(M),
    ///mark a rule to appear as just a string in the AST. Whatever structure is found within, throw it away and just store
    ///whatever was parsed.
    ///
    ///Note that any AST node has the .as_str() method to request this string representation of the node. For
    ///single-string rules this is simply the default.
    SingleString(M),
    ///don't accept any layout characters while parsing this rule
    NoLayout(M),
    ///Annotation for sorts. This sort will not appear in any of the constructors it's used in.
    ///useful for for example the [`newline`] rule in this file.
    Hidden(M),
    ///if this rule manages to parse, display an error with the associated message
    ///This annotation can be placed on constructors (these constructors then won't actually exist in the AST,
    ///if the constructor is chosen an error is emitted), or on sorts. On a sort the annotation
    ///has a slightly different effect. If none of the variants in the sort managed to parse
    ///then alongside an "expected ...", that message will be displayed as well.
    ///If this sort was the only possibility at a certain point, only the message will be displayed.
    Error(M, String<M>),
    ///Makes constructors of this rule generate as part of another rule.
    ///This has one major requirement. If a is part-of b then
    ///b must have a rule like `a=a` to allow any a to appear in b
    ///
    ///Injections on rule a become injections into rule b too.
    PartOf(M, Identifier<M>),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum Atom<M> {
    ///Matches a piece of text exactly. Layout is parsed within a literal.
    Literal(M, String<M>),
    ///You can use parentheses to group parts of expressions.
    Paren(M, Vec<Box<Expression<M>>>),
    Labelled(M, Identifier<M>, Box<Atom<M>>),
    ///Reference another sort within this expression.
    ///That sort should be parsed in this position in the expression.
    Sort(M, Identifier<M>),
    ///A [`character class`](character-class) (range of characters) should be parsed here.
    Class(M, CharacterClass<M>),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct Number<M>(pub M, pub std::string::String);
///A delimited expression can be repeated just like normal repetition expressions.
///To denote this, you can use a delimitation bound.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum DelimitedBound<M> {
    ///Within a range or possible repetitions.
    NumNum(M, Number<M>, Number<M>),
    ///At least some number of repetitions, but no upper bound.
    NumInf(M, Number<M>),
    ///Exactly this number of repetitions.
    Num(M, Number<M>),
    Star(M),
    ///One or more repetitions.
    Plus(M),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum String<M> {
    Single(M, Vec<StringChar<M>>),
    Double(M, Vec<StringChar<M>>),
}
///A character class represent a selection of terminal characters. This is similar to
///Regex character classes. Character classes can be inverted by starting them with a `^`.
///For example, `[^\n]` means it matches any character that is not a newline.
///
///Character classes can contain a range of characters. Either by listing each individual character, or using
///a dash (`-`). For example, `[a-z]` means any character in the range a through z (inclusive!),
///and `[abc]` means an a, b or c
///
///Note that to use a closing square bracket within a character class, you need to escape it.
///
///`[^\]]` means any character that isn't a square bracket.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub struct CharacterClass<M>(pub M, pub bool, pub Vec<CharacterClassItem<M>>);
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum StringChar<M> {
    Escaped(M, std::string::String),
    Normal(M, std::string::String),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum CharacterClassItem<M> {
    Range(M, EscapeClosingBracket<M>, EscapeClosingBracket<M>),
    SingleChar(M, EscapeClosingBracket<M>),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum EscapeClosingBracket<M> {
    Escaped(M, std::string::String),
    Unescaped(M, std::string::String),
}
#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(crate = "self::serde")]
pub enum Layout<M> {
    Simple(M, std::string::String),
    Comment(M, Vec<std::string::String>),
}
pub type AST_ROOT<M> = Program<M>;
