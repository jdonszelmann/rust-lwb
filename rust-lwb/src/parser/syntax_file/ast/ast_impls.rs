#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
// Generated at 17/04/2022 23:31:51 +02:00 - 17/04/2022 21:31:51 UTC
use super::prelude::*;

impl<M: AstInfo> AstNode<M> for Identifier<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "identifier"
        }

    }

    fn sort(&self) -> &'static str {
        "identifier"
    }
}

impl<M: AstInfo> AstNode<M> for EscapeClosingBracket<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Escaped(meta, ..) => {
            meta
        }

        Self::Unescaped(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Escaped(meta, ..) => {
            "escaped"
        }

        Self::Unescaped(meta, ..) => {
            "unescaped"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "escape-closing-bracket"
    }
}

impl<M: AstInfo> AstNode<M> for CharacterClassItem<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Range(meta, ..) => {
            meta
        }

        Self::SingleChar(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Range(meta, ..) => {
            "range"
        }

        Self::SingleChar(meta, ..) => {
            "single-char"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "character-class-item"
    }
}

impl<M: AstInfo> AstNode<M> for StringChar<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Escaped(meta, ..) => {
            meta
        }

        Self::Normal(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Escaped(meta, ..) => {
            "escaped"
        }

        Self::Normal(meta, ..) => {
            "normal"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "string-char"
    }
}

impl<M: AstInfo> AstNode<M> for Number<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "number"
        }

    }

    fn sort(&self) -> &'static str {
        "number"
    }
}

impl<M: AstInfo> AstNode<M> for CharacterClass<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "class"
        }

    }

    fn sort(&self) -> &'static str {
        "character-class"
    }
}

impl<M: AstInfo> AstNode<M> for Expression<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Star(meta, ..) => {
            meta
        }

        Self::Plus(meta, ..) => {
            meta
        }

        Self::Maybe(meta, ..) => {
            meta
        }

        Self::RepeatExact(meta, ..) => {
            meta
        }

        Self::Literal(meta, ..) => {
            meta
        }

        Self::SingleQuoteLiteral(meta, ..) => {
            meta
        }

        Self::Delimited(meta, ..) => {
            meta
        }

        Self::Sort(meta, ..) => {
            meta
        }

        Self::Class(meta, ..) => {
            meta
        }

        Self::Paren(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Star(meta, ..) => {
            "star"
        }

        Self::Plus(meta, ..) => {
            "plus"
        }

        Self::Maybe(meta, ..) => {
            "maybe"
        }

        Self::RepeatExact(meta, ..) => {
            "repeat-exact"
        }

        Self::Literal(meta, ..) => {
            "literal"
        }

        Self::SingleQuoteLiteral(meta, ..) => {
            "single-quote-literal"
        }

        Self::Delimited(meta, ..) => {
            "delimited"
        }

        Self::Sort(meta, ..) => {
            "sort"
        }

        Self::Class(meta, ..) => {
            "class"
        }

        Self::Paren(meta, ..) => {
            "paren"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "expression"
    }
}

impl<M: AstInfo> AstNode<M> for DelimitedBound<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::NumNum(meta, ..) => {
            meta
        }

        Self::NumInf(meta, ..) => {
            meta
        }

        Self::Num(meta, ..) => {
            meta
        }

        Self::Star(meta, ..) => {
            meta
        }

        Self::Plus(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::NumNum(meta, ..) => {
            "num-num"
        }

        Self::NumInf(meta, ..) => {
            "num-inf"
        }

        Self::Num(meta, ..) => {
            "num"
        }

        Self::Star(meta, ..) => {
            "star"
        }

        Self::Plus(meta, ..) => {
            "plus"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "delimited-bound"
    }
}

impl<M: AstInfo> AstNode<M> for Annotation<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "annotation"
        }

    }

    fn sort(&self) -> &'static str {
        "annotation"
    }
}

impl<M: AstInfo> AstNode<M> for Constructor<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "constructor"
        }

    }

    fn sort(&self) -> &'static str {
        "constructor"
    }
}

impl<M: AstInfo> AstNode<M> for Newline<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Unix(meta, ..) => {
            meta
        }

        Self::Windows(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Unix(meta, ..) => {
            "unix"
        }

        Self::Windows(meta, ..) => {
            "windows"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "newline"
    }
}

impl<M: AstInfo> AstNode<M> for Sort<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Sort(meta, ..) => {
            meta
        }

        Self::SortSingle(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Sort(meta, ..) => {
            "sort"
        }

        Self::SortSingle(meta, ..) => {
            "sort-single"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "sort"
    }
}

impl<M: AstInfo> AstNode<M> for Meta<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "start"
        }

    }

    fn sort(&self) -> &'static str {
        "meta"
    }
}

impl<M: AstInfo> AstNode<M> for SortOrMeta<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Meta(meta, ..) => {
            meta
        }

        Self::Sort(meta, ..) => {
            meta
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Meta(meta, ..) => {
            "meta"
        }

        Self::Sort(meta, ..) => {
            "sort"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "sort-or-meta"
    }
}

impl<M: AstInfo> AstNode<M> for Program<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "program"
        }

    }

    fn sort(&self) -> &'static str {
        "program"
    }
}

impl<M: AstInfo> AstNode<M> for Layout<M> {
    fn ast_info(&self) -> &M {
        let meta = &self.0;
        {
            meta
        }

    }

    fn constructor(&self) -> &'static str {
        let meta = &self.0;
        {
            "layout"
        }

    }

    fn sort(&self) -> &'static str {
        "layout"
    }
}