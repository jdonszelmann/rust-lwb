#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
// Generated at 06/02/2022 21:44:13 +01:00 - 06/02/2022 20:44:13 UTC
use super::prelude::*;

impl<M: AstInfo> AstNode<M> for Identifier<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Identifier(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Identifier(info, ..) => {
            "identifier"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "identifier"
    }
}

impl<M: AstInfo> AstNode<M> for EscapeClosingBracket<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Escaped(info, ..) => {
            info
        }

        Self::Unescaped(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Escaped(info, ..) => {
            "escaped"
        }

        Self::Unescaped(info, ..) => {
            "unescaped"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "escape-closing-bracket"
    }
}

impl<M: AstInfo> AstNode<M> for CharacterClassItem<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Range(info, ..) => {
            info
        }

        Self::SingleChar(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Range(info, ..) => {
            "range"
        }

        Self::SingleChar(info, ..) => {
            "single-char"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "character-class-item"
    }
}

impl<M: AstInfo> AstNode<M> for StringChar<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Escaped(info, ..) => {
            info
        }

        Self::Normal(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Escaped(info, ..) => {
            "escaped"
        }

        Self::Normal(info, ..) => {
            "normal"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "string-char"
    }
}

impl<M: AstInfo> AstNode<M> for Number<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Number(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Number(info, ..) => {
            "number"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "number"
    }
}

impl<M: AstInfo> AstNode<M> for CharacterClass<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Class(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Class(info, ..) => {
            "class"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "character-class"
    }
}

impl<M: AstInfo> AstNode<M> for Expression<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Star(info, ..) => {
            info
        }

        Self::Plus(info, ..) => {
            info
        }

        Self::Maybe(info, ..) => {
            info
        }

        Self::RepeatExact(info, ..) => {
            info
        }

            Self::Literal(info, ..) => {
                info
            }

            Self::SingleQuoteLiteral(info, ..) => {
                info
            }

            Self::Delimited(info, ..) => {
                info
            }

            Self::Sort(info, ..) => {
                info
            }

            Self::Class(info, ..) => {
                info
            }

            Self::Paren(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Star(info, ..) => {
            "star"
        }

        Self::Plus(info, ..) => {
            "plus"
        }

        Self::Maybe(info, ..) => {
            "maybe"
        }

        Self::RepeatExact(info, ..) => {
            "repeat-exact"
        }

            Self::Literal(info, ..) => {
                "literal"
            }

            Self::SingleQuoteLiteral(info, ..) => {
                "single-quote-literal"
            }

            Self::Delimited(info, ..) => {
                "delimited"
            }

            Self::Sort(info, ..) => {
                "sort"
            }

            Self::Class(info, ..) => {
                "class"
            }

            Self::Paren(info, ..) => {
            "paren"
            }
        }
    }

    fn sort(&self) -> &'static str {
        "expression"
    }
}

impl<M: AstInfo> AstNode<M> for DelimitedBound<M> {
    fn ast_info(&self) -> &M {
        match self {
            Self::NumNum(info, ..) => {
                info
            }

            Self::NumInf(info, ..) => {
                info
            }

            Self::Num(info, ..) => {
                info
            }

            Self::Star(info, ..) => {
                info
            }

            Self::Plus(info, ..) => {
                info
            }
        }
    }

    fn constructor(&self) -> &'static str {
        match self {
            Self::NumNum(info, ..) => {
                "num-num"
            }

            Self::NumInf(info, ..) => {
                "num-inf"
            }

            Self::Num(info, ..) => {
                "num"
            }

            Self::Star(info, ..) => {
                "star"
            }

            Self::Plus(info, ..) => {
                "plus"
            }
        }
    }

    fn sort(&self) -> &'static str {
        "delimited-bound"
    }
}

impl<M: AstInfo> AstNode<M> for Annotation<M> {
    fn ast_info(&self) -> &M {
        match self {
            Self::Annotation(info, ..) => {
                info
            }
        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Annotation(info, ..) => {
            "annotation"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "annotation"
    }
}

impl<M: AstInfo> AstNode<M> for Constructor<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Constructor(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Constructor(info, ..) => {
            "constructor"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "constructor"
    }
}

impl<M: AstInfo> AstNode<M> for Newline<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Unix(info, ..) => {
            info
        }

        Self::Windows(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Unix(info, ..) => {
            "unix"
        }

        Self::Windows(info, ..) => {
            "windows"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "newline"
    }
}

impl<M: AstInfo> AstNode<M> for Sort<M> {
    fn ast_info(&self) -> &M {
        match self {
            Self::Sort(info, ..) => {
                info
            }

            Self::SortSingle(info, ..) => {
                info
            }
        }
    }

    fn constructor(&self) -> &'static str {
        match self {
            Self::Sort(info, ..) => {
                "sort"
            }

            Self::SortSingle(info, ..) => {
                "sort-single"
            }
        }
    }

    fn sort(&self) -> &'static str {
        "sort"
    }
}

impl<M: AstInfo> AstNode<M> for Meta<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Start(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Start(info, ..) => {
            "start"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "meta"
    }
}

impl<M: AstInfo> AstNode<M> for SortOrMeta<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Meta(info, ..) => {
            info
        }

        Self::Sort(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Meta(info, ..) => {
            "meta"
        }

        Self::Sort(info, ..) => {
            "sort"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "sort-or-meta"
    }
}

impl<M: AstInfo> AstNode<M> for Program<M> {
    fn ast_info(&self) -> &M {
        match self {
        Self::Program(info, ..) => {
            info
        }

        }
    }

    fn constructor(&self) -> &'static str {
        match self {
        Self::Program(info, ..) => {
            "program"
        }

        }
    }

    fn sort(&self) -> &'static str {
        "program"
    }
}

impl<M: AstInfo> AstNode<M> for Layout<M> {
    fn ast_info(&self) -> &M {
        match self {
            Self::Layout(info, ..) => {
                info
            }
        }
    }

    fn constructor(&self) -> &'static str {
        match self {
            Self::Layout(info, ..) => {
                "layout"
            }
        }
    }

    fn sort(&self) -> &'static str {
        "layout"
    }
}