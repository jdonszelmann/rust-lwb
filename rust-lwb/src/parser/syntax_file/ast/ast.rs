#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
use super::prelude::*;

/// An identifier is any name of a constructor or sort, and is used in various places.
/// Identifiers always start with a letter (capital or not) or an underscore, and can be
/// followed by letters or numbers. This is very similar to how variables in most major
/// programming languages work.
#[derive(Debug, Serialize, Deserialize)]
pub struct Identifier<M : AstInfo>(pub M, pub String);

#[derive(Debug, Serialize, Deserialize)]
pub enum EscapeClosingBracket<M : AstInfo> {
    Escaped(M, String),
    Unescaped(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum CharacterClassItem<M : AstInfo> {
    Range(M, Box<EscapeClosingBracket<M>>, Box<EscapeClosingBracket<M>>, ),
    SingleChar(M, Box<EscapeClosingBracket<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StringChar<M : AstInfo> {
    Escaped(M, String),
    Normal(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Number<M : AstInfo>(pub M, pub String);

/// A character class represent a selection of terminal characters. This is similar to
/// Regex character classes. Character classes can be inverted by starting them with a `^`.
/// For example, `[^\n]` means it matches any character that is not a newline.
/// 
/// Character classes can contain a range of characters. Either by listing each individual character, or using
/// a dash (`-`). For example, `[a-z]` means any character in the range a through z, and `[abc]` means an a, b or c
/// 
/// Note that to use a closing square bracket within a character class, you need to escape it.
/// 
/// `[^\]]` means any character that isn't a square bracket.
#[derive(Debug, Serialize, Deserialize)]
pub struct CharacterClass<M : AstInfo>(pub M, pub bool, pub Vec<Box<CharacterClassItem<M>>>, );

#[derive(Debug, Serialize, Deserialize)]
pub enum Expression<M : AstInfo> {
    Star(M, Box<Expression<M>>),
    Plus(M, Box<Expression<M>>),
    Maybe(M, Box<Expression<M>>),
    RepeatExact(M, Box<Expression<M>>, Box<Number<M>>, Option<Box<Number<M>>>, ),
    Literal(M, Vec<Box<StringChar<M>>>),
    SingleQuoteLiteral(M, Vec<Box<StringChar<M>>>),
    Delimited(M, Box<Expression<M>>, Box<Expression<M>>, Box<DelimitedBound<M>>, bool, ),
    Sort(M, Box<Identifier<M>>),
    Class(M, Box<CharacterClass<M>>),
    Paren(M, Vec<Box<Expression<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum DelimitedBound<M : AstInfo> {
    NumNum(M, Box<Number<M>>, Box<Number<M>>, ),
    NumInf(M, Box<Number<M>>),
    Num(M, Box<Number<M>>),
    Star(M, ),
    Plus(M, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Annotation<M : AstInfo>(pub M, pub Vec<Box<Identifier<M>>>);

#[derive(Debug, Serialize, Deserialize)]
pub enum Constructor<M : AstInfo> {
    Constructor(M, Box<Identifier<M>>, Vec<Box<Expression<M>>>, Option<Box<Annotation<M>>>, ),
    ConstructorDocumented(M, Vec<Box<DocComment<M>>>, Box<Constructor<M>>, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Newline<M : AstInfo> {
    Unix(M, ),
    Windows(M, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Sort<M : AstInfo> {
    SortDocumented(M, Vec<Box<DocComment<M>>>, Box<Sort<M>>, ),
    Sort(M, Box<Identifier<M>>, Vec<Box<Constructor<M>>>, ),
    SortSingle(M, Box<Identifier<M>>, Vec<Box<Expression<M>>>, Option<Box<Annotation<M>>>, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Meta<M : AstInfo>(pub M, pub Box<Identifier<M>>);

#[derive(Debug, Serialize, Deserialize)]
pub enum SortOrMeta<M : AstInfo> {
    Meta(M, Box<Meta<M>>),
    Sort(M, Box<Sort<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Program<M : AstInfo>(pub M, pub Vec<Box<SortOrMeta<M>>>);

#[derive(Debug, Serialize, Deserialize)]
pub struct DocComment<M : AstInfo>(pub M, pub String);

#[derive(Debug, Serialize, Deserialize)]
pub enum Layout<M : AstInfo> {
    Simple(M, String),
    Comment(M, Vec<String>),
}

pub type AST_ROOT<M> = Program<M>;