#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
use super::prelude::*;

#[derive(Debug, Serialize, Deserialize)]
pub struct Identifier<M : AstInfo>(pub M, pub String);

#[derive(Debug, Serialize, Deserialize)]
pub enum EscapeClosingBracket<M : AstInfo> {
    Escaped(M, String),
    Unescaped(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum CharacterClassItem<M : AstInfo> {
    Range(M, Box<EscapeClosingBracket<M>>, Box<EscapeClosingBracket<M>>, ),
    SingleChar(M, Box<EscapeClosingBracket<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StringChar<M : AstInfo> {
    Escaped(M, String),
    Normal(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Number<M : AstInfo>(pub M, pub String);

#[derive(Debug, Serialize, Deserialize)]
pub struct CharacterClass<M : AstInfo>(pub M, pub bool, pub Vec<Box<CharacterClassItem<M>>>, );

#[derive(Debug, Serialize, Deserialize)]
pub enum Expression<M : AstInfo> {
    Star(M, Box<Expression<M>>),
    Plus(M, Box<Expression<M>>),
    Maybe(M, Box<Expression<M>>),
    RepeatExact(M, Box<Expression<M>>, Box<Number<M>>, Option<Box<Number<M>>>, ),
    Literal(M, Vec<Box<StringChar<M>>>),
    SingleQuoteLiteral(M, Vec<Box<StringChar<M>>>),
    Delimited(M, Box<Expression<M>>, Box<Expression<M>>, Box<DelimitedBound<M>>, bool, ),
    Sort(M, Box<Identifier<M>>),
    Class(M, Box<CharacterClass<M>>),
    Paren(M, Vec<Box<Expression<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum DelimitedBound<M : AstInfo> {
    NumNum(M, Box<Number<M>>, Box<Number<M>>, ),
    NumInf(M, Box<Number<M>>),
    Num(M, Box<Number<M>>),
    Star(M, ),
    Plus(M, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Annotation<M : AstInfo>(pub M, pub Vec<Box<Identifier<M>>>);

#[derive(Debug, Serialize, Deserialize)]
pub struct Constructor<M : AstInfo>(pub M, pub Box<Identifier<M>>, pub Vec<Box<Expression<M>>>, pub Option<Box<Annotation<M>>>, );

#[derive(Debug, Serialize, Deserialize)]
pub enum Newline<M : AstInfo> {
    Unix(M, ),
    Windows(M, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Sort<M : AstInfo> {
    Sort(M, Box<Identifier<M>>, Vec<Box<Constructor<M>>>, ),
    SortSingle(M, Box<Identifier<M>>, Vec<Box<Expression<M>>>, Option<Box<Annotation<M>>>, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Meta<M : AstInfo>(pub M, pub Box<Identifier<M>>);

#[derive(Debug, Serialize, Deserialize)]
pub enum SortOrMeta<M : AstInfo> {
    Meta(M, Box<Meta<M>>),
    Sort(M, Box<Sort<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Program<M : AstInfo>(pub M, pub Vec<Box<SortOrMeta<M>>>);

#[derive(Debug, Serialize, Deserialize)]
pub struct Layout<M : AstInfo>(pub M, pub String);

pub type AST_ROOT<M> = Program<M>;