#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
// Generated at 06/02/2022 16:07:50 +01:00 - 06/02/2022 15:07:50 UTC
use super::prelude::*;

#[derive(Debug, Serialize, Deserialize)]
pub enum Identifier<M : AstInfo> {
    Identifier(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum EscapeClosingBracket<M : AstInfo> {
    Escaped(M, String),
    Unescaped(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum CharacterClassItem<M : AstInfo> {
    Range(M, Box<EscapeClosingBracket<M>>,Box<EscapeClosingBracket<M>>),
    SingleChar(M, Box<EscapeClosingBracket<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StringChar<M : AstInfo> {
    Escaped(M, String),
    Normal(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Number<M : AstInfo> {
    Number(M, String),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum CharacterClass<M : AstInfo> {
    Class(M, bool,Vec<Box<CharacterClassItem<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Expression<M : AstInfo> {
    Star(M, Box<Expression<M>>),
    Plus(M, Box<Expression<M>>),
    Maybe(M, Box<Expression<M>>),
    RepeatExact(M, Box<Expression<M>>,Box<Number<M>>,Option<Box<Number<M>>>),
    Literal(M, Vec<Box<StringChar<M>>>),
    SingleQuoteLiteral(M, Vec<Box<StringChar<M>>>),
    Sort(M, Box<Identifier<M>>),
    Class(M, Box<CharacterClass<M>>),
    Paren(M, Vec<Box<Expression<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Annotation<M : AstInfo> {
    Annotation(M, Option<Box<Identifier<M>>>,Vec<Box<Identifier<M>>>,bool),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Constructor<M : AstInfo> {
    Constructor(M, Box<Identifier<M>>,Vec<Box<Expression<M>>>,Option<Box<Annotation<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Newline<M : AstInfo> {
    Unix(M, ),
    Windows(M, ),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Sort<M : AstInfo> {
    Sort(M, Box<Identifier<M>>, Vec<Box<Constructor<M>>>),
    SortSingle(M, Box<Identifier<M>>, Vec<Box<Expression<M>>>, Option<Box<Annotation<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Meta<M : AstInfo> {
    Start(M, Box<Identifier<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum SortOrMeta<M: AstInfo> {
    Meta(M, Box<Meta<M>>),
    Sort(M, Box<Sort<M>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Program<M: AstInfo> {
    Program(M, Vec<Box<SortOrMeta<M>>>),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Layout<M: AstInfo> {
    Layout(M, String),
}

pub type AST_ROOT<M> = Program<M>;