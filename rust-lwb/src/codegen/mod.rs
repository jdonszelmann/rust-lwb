use crate::parser::bootstrap::ast::{Expression, SyntaxFileAst};
use codegen::{Block, Function, Scope};
use convert_case::{Case, Casing};

pub mod manager;

pub fn sanitize_identifier(id: &str) -> String {
    id.to_case(Case::UpperCamel)
}

pub fn generate_language(syntax: SyntaxFileAst) -> String {
    let mut scope = Scope::new();

    scope.import("rust_lwb::codegen_prelude", "*");

    for rule in &syntax.sorts {
        let enumm = scope.new_enum(&sanitize_identifier(&rule.name));
        enumm.generic("M : AstInfo");
        for constr in &rule.constructors {
            let variant = enumm.new_variant(&sanitize_identifier(&constr.name));
            variant.tuple("M");
            let typ =
                generate_constructor_type(&constr.constructor).unwrap_or_else(|| "()".to_string());
            let typ = if typ.starts_with('(') {
                &typ[1..typ.len() - 1]
            } else {
                &typ
            };
            variant.tuple(typ);
        }
    }

    // TODO: put these definition in a different file
    for rule in &syntax.sorts {
        let mut f = Function::new("from_pairs");
        f.generic("G: GenerateAstInfo");
        f.arg("pair", "ParsePairSort");
        f.arg("generator", "G");
        f.ret("Self");
        // f.line("let info = generate.generate(&pair)");
        // f.line("assert_eq!(f.sort);");
        // f.line("match pair.");

        scope.new_impl(&format!("{}<M>", sanitize_identifier(&rule.name)))
            .impl_trait("FromPairs<M>")
            .generic("M: AstInfo")
            .push_fn(f);
    }

    format!("#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
// |==========================================================|
// | WARNING: THIS FILE IS AUTOMATICALLY GENERATED.           |
// | CHANGES TO IT WILL BE DELETED WHEN REGENERATED.          |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|


{}", scope.to_string())
}

fn generate_constructor_type(constructor: &Expression) -> Option<String> {
    match constructor {
        Expression::Sort(sort) => Some(String::from_iter(["Box<", &sanitize_identifier(sort), "<M>>"])),
        Expression::Sequence(cons) => {
            let mut s = String::new();
            s.push('(');
            for con in cons {
                if let Some(con_type) = generate_constructor_type(con) {
                    s.push_str(&con_type);
                    s.push(',');
                }
            }
            s.push(')');
            if s.len() > 2 {
                Some(s)
            } else {
                None
            }
        }
        Expression::Repeat { c, min, max } => {
            let subtype = generate_constructor_type(c.as_ref())?;
            match (min, max) {
                (0, Some(1)) => Some(String::from_iter(["Option<", &subtype, ">"])),
                _ => Some(String::from_iter(["Vec<", &subtype, ">"])),
            }
        }
        Expression::Choice(_) => None, //TODO how to represent choice?
        Expression::CharacterClass(_) => None,
        Expression::Negative(_) => None,
        Expression::Positive(_) => None,
        Expression::Literal(_) => None,
    }
}

#[cfg(test)]
mod tests {
    use crate::codegen::generate_language;
    use crate::parser::bootstrap::ast::{Constructor, Expression, Sort, SyntaxFileAst};
    use crate::sources::character_class::CharacterClass;

    #[test]
    pub fn run_example() {
        let ast = SyntaxFileAst {
            sorts: vec![Sort {
                name: "AS".to_string(),
                constructors: vec![
                    Constructor {
                        name: "More".to_string(),
                        constructor: Expression::Sequence(vec![
                            Expression::Literal("a".to_string()),
                            Expression::Sort("AS".to_string()),
                        ]),
                        annotations: vec![],
                    },
                    Constructor {
                        name: "NoMore".to_string(),
                        constructor: Expression::Sequence(vec![]),
                        annotations: vec![],
                    },
                ],
            }],
            starting_sort: "A".to_string(),
            layout: CharacterClass::Nothing,
        };
        generate_language(ast);
    }
}
