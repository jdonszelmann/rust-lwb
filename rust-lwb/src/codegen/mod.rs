use crate::parser::bootstrap::ast::{Expression, SyntaxFileAst};
use codegen::{Block, Function, Scope};
use convert_case::{Case, Casing};
use std::ops::Deref;

mod error;
mod generate_headers;
mod generate_trait_impls;
mod generate_from_pairs;
pub mod manager;
pub mod generate_ast;

fn sanitize_identifier(id: &str) -> String {
    id.to_case(Case::UpperCamel)
}



// pub fn generate_language(
//     syntax: SyntaxFileAst,
//     import_location: &str,
//     serde: bool,
//     serialized_parser: Option<&[u8]>,
// ) -> String {
//     let mut scope = Scope::new();
//
//     scope.import(&format!("{}::codegen_prelude", import_location), "*");
//
//     for rule in &syntax.sorts {
//         let enumm = scope.new_enum(&sanitize_identifier(&rule.name));
//         enumm.vis("pub");
//
//         if serde {
//             enumm.derive("Serialize");
//             enumm.derive("Deserialize");
//         }
//
//         enumm.derive("Debug");
//
//         enumm.generic("M : AstInfo");
//         for constr in &rule.constructors {
//             let variant = enumm.new_variant(&sanitize_identifier(&constr.name));
//             variant.tuple("M");
//
//             let typ = if constr.annotations.contains(&SingleString) {
//                 "String".to_string()
//             } else {
//                 generate_constructor_type(&constr.expression).unwrap_or_else(|| "()".to_string())
//             };
//
//             let typ = if typ.starts_with('(') {
//                 &typ[1..typ.len() - 1]
//             } else {
//                 &typ
//             };
//             variant.tuple(typ);
//         }
//     }
//
//     scope.raw(&format!(
//         "pub type AST_ROOT<M> = {}<M>;",
//         sanitize_identifier(&syntax.starting_sort)
//     ));
//
//     // TODO: put these definition in a different file
//     for rule in &syntax.sorts {
//         let mut f = Function::new("from_pairs");
//         f.generic("G: GenerateAstInfo<Result = M>");
//         f.arg("pair", "&ParsePairSort");
//         f.arg("generator", "&mut G");
//         f.ret("Self");
//         f.line(format!(r#"assert_eq!(pair.sort, "{}");"#, rule.name));
//         f.line("let info = generator.generate(&pair);");
//         f.line("match pair.constructor_name {");
//
//         for constructor in &rule.constructors {
//             f.line(format!(r#""{}" => {{"#, constructor.name));
//             generate_unpack(
//                 &mut f,
//                 &rule.name,
//                 &sanitize_identifier(&constructor.name),
//                 &constructor.expression,
//                 constructor.annotations.contains(&SingleString),
//             );
//             f.line("}");
//         }
//
//         f.line(r#"a => unreachable!("{}", a)"#);
//         f.line("}");
//
//         scope
//             .new_impl(&format!("{}<M>", sanitize_identifier(&rule.name)))
//             .impl_trait("FromPairs<M>")
//             .generic("M: AstInfo")
//             .push_fn(f);
//     }
//
//     for rule in &syntax.sorts {
//         let imp = scope
//             .new_impl(&format!("{}<M>", sanitize_identifier(&rule.name)))
//             .impl_trait("AstNode<M>")
//             .generic("M: AstInfo");
//
//         let mut block = Block::new("");
//         block.line("match self {");
//         for constructor in &rule.constructors {
//             block.line(format!(
//                 r#"Self::{}(info, ..) => {{ info }}"#,
//                 sanitize_identifier(&constructor.name)
//             ));
//         }
//         block.line("}");
//
//         let mut f = Function::new("ast_info");
//         f.arg_ref_self().ret("&M").push_block(block);
//
//         imp.push_fn(f);
//     }
//
//     if let Some(i) = serialized_parser {
//         scope.raw(&format!(r##"pub const PARSER: &[u8] = &{:?};"##, i));
//     }
//
//     format!(
//         "
// #![allow(unused)]
// #![allow(non_snake_case)]
// #![allow(non_camel_case_types)]
// #![allow(clippy::all)]
// // |==========================================================|
// // | WARNING: THIS FILE IS AUTOMATICALLY GENERATED.           |
// // | CHANGES TO IT WILL BE DELETED WHEN REGENERATED.          |
// // | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// // |==========================================================|
//
//
// {}",
//         scope.to_string()
//     )
// }
//
