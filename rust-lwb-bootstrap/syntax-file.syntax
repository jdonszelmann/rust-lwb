
/// An identifier is any name of a constructor or sort, and is used in various places.
/// Identifiers always start with a letter (capital or not) or an underscore, and can be
/// followed by letters or numbers. This is very similar to how variables in most major
/// programming languages work.
identifier = [A-Za-z_][A-Za-z0-9-_]*; {no-layout, single-string}

escape-closing-bracket:
    escaped = "\\" [\]nrt\\];
    unescaped = [^\]];

character-class-item:
    range = escape-closing-bracket  "-" escape-closing-bracket;
    single-char = escape-closing-bracket; {injection}


string-char:
    escaped = "\\" [nrt\\"];
    normal = [^"\\];

number = [0-9]+; {single-string}

/// A character class represent a selection of terminal characters. This is similar to
/// Regex character classes. Character classes can be inverted by starting them with a `^`.
/// For example, `[^\n]` means it matches any character that is not a newline.
///
/// Character classes can contain a range of characters. Either by listing each individual character, or using
/// a dash (`-`). For example, `[a-z]` means any character in the range a through z, and `[abc]` means an a, b or c
///
/// Note that to use a closing square bracket within a character class, you need to escape it.
///
/// `[^\]]` means any character that isn't a square bracket.
character-class:
    class =  "[" "^"? character-class-item* "]"; {no-layout}

expression:
    star = expression "*";
    plus = expression "+";
    maybe = expression "?";
    repeat-exact = expression "{" number "," number? "}";

    literal = "\"" string-char* "\""; {no-layout}
    single-quote-literal = "'" string-char* "'"; {no-layout}

    delimited = "delimited" "(" expression "," expression "," delimited-bound ("," "trailing")? ")";

    sort = identifier;
    class = character-class;

    paren = "(" expression+ ")"; {injection}

delimited-bound:
    num-num = number "," number;
    num-inf = number "," "inf";
    num = number;
    star = "*";
    plus = "+";

annotation = "{" delimited(identifier, ",", +, trailing) "}";

constructor:
    constructor = "    " identifier "=" expression+ ";" annotation?;
    constructor-documented = doc-comment+ constructor;

newline:
    unix = "\n";
    windows = "\r\n";

sort:
    sort-documented = doc-comment+ sort;
    sort = identifier ":" constructor*;
    sort-single = identifier "=" expression+ ";" annotation?;

meta:
    start = "start" "at" identifier ";";

sort-or-meta:
    meta = meta;
    sort = sort;

program = sort-or-meta*;

doc-comment = "///" [^\n]*; {no-layout, single-string}

layout:
    simple = [\n\r\t ];
    comment = "//" [^\n]*;

start at program;