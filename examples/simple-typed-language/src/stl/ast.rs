#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(clippy::all)]
// |==========================================================|
// |      WARNING: THIS FILE IS AUTOMATICALLY GENERATED.      |
// |      CHANGES TO IT WILL BE DELETED WHEN REGENERATED.     |
// | IN GENERAL, THIS FILE SHOULD NOT BE MODIFIED IN ANY WAY. |
// |==========================================================|
use super::prelude::*;
#[derive(Debug)]
pub struct Identifier<M: AstInfo>(pub M, pub String);
#[derive(Debug)]
#[non_exhaustive]
pub struct Int<M: AstInfo>(pub M, pub Vec<String>, #[doc(hidden)] pub NonExhaustive);
#[derive(Debug)]
#[non_exhaustive]
pub enum Bool<M: AstInfo> {
    True(M, #[doc(hidden)] NonExhaustive),
    False(M, #[doc(hidden)] NonExhaustive),
    #[doc(hidden)]
    __NonExhaustive(NonExhaustive),
}
#[derive(Debug)]
#[non_exhaustive]
pub enum Expression<M: AstInfo> {
    Add(
        M,
        Box<Expression<M>>,
        Box<Expression<M>>,
        #[doc(hidden)] NonExhaustive,
    ),
    Sub(
        M,
        Box<Expression<M>>,
        Box<Expression<M>>,
        #[doc(hidden)] NonExhaustive,
    ),
    Eq(
        M,
        Box<Expression<M>>,
        Box<Expression<M>>,
        #[doc(hidden)] NonExhaustive,
    ),
    Index(
        M,
        Box<Expression<M>>,
        Box<Expression<M>>,
        #[doc(hidden)] NonExhaustive,
    ),
    Testexpr(
        M,
        Box<Int<M>>,
        Box<Bool<M>>,
        Box<Int<M>>,
        Box<Bool<M>>,
        Box<Bool<M>>,
        Box<Int<M>>,
        Box<Bool<M>>,
        Box<Bool<M>>,
        Box<Int<M>>,
        Box<Bool<M>>,
        Box<Int<M>>,
        #[doc(hidden)] NonExhaustive,
    ),
    List(M, Vec<Box<Expression<M>>>, #[doc(hidden)] NonExhaustive),
    Bool(M, Box<Bool<M>>, #[doc(hidden)] NonExhaustive),
    Int(M, Box<Int<M>>, #[doc(hidden)] NonExhaustive),
    Identifier(M, Box<Identifier<M>>, #[doc(hidden)] NonExhaustive),
    Paren(M, Box<Expression<M>>, #[doc(hidden)] NonExhaustive),
    #[doc(hidden)]
    __NonExhaustive(NonExhaustive),
}
#[derive(Debug)]
#[non_exhaustive]
pub enum Statement<M: AstInfo> {
    If(
        M,
        Box<Expression<M>>,
        Vec<Box<Statement<M>>>,
        #[doc(hidden)] NonExhaustive,
    ),
    Expression(M, Box<Expression<M>>, #[doc(hidden)] NonExhaustive),
    Assignment(
        M,
        Box<Identifier<M>>,
        Box<Expression<M>>,
        #[doc(hidden)] NonExhaustive,
    ),
    #[doc(hidden)]
    __NonExhaustive(NonExhaustive),
}
#[derive(Debug)]
#[non_exhaustive]
pub struct Program<M: AstInfo>(
    pub M,
    pub Vec<Box<Statement<M>>>,
    #[doc(hidden)] pub NonExhaustive,
);
#[derive(Debug)]
#[non_exhaustive]
pub struct Layout<M: AstInfo>(pub M, pub String, #[doc(hidden)] pub NonExhaustive);
pub type AST_ROOT<M> = Program<M>;
